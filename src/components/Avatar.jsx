/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public\models\67e90607d9b62ad194b6ee87.glb -o src/components/Avatar.jsx -r public 
*/

import { useState, useMemo, useEffect, useRef } from 'react'
import { useFrame, useGraph, useLoader } from '@react-three/fiber'
import { useAnimations, useFBX, useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { useControls } from 'leva'
import * as THREE from "three";

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export function Avatar(props) {
  const {playAudio, script} = useControls(
    {
      playAudio: false,
      script: {
        value: "sample_voice",
        options: ["sample_voice", "sample_voice_2", "greeting"]
      }
    }
  )

  // Keep reference to current audio for cleanup
  const audioRef = useRef(null);
  const jsonRef = useRef(null);
  const lipsyncRef = useRef(null);
  const prevScriptRef = useRef(script);
  
  // Create audio and load JSON only when script changes
  useEffect(() => {
    // Clean up previous audio 
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.removeAttribute('src');
      audioRef.current = null;
    }
    
    // Create new audio instance
    const newAudio = new Audio(`/audios/${script}.mp3`);
    audioRef.current = newAudio;
    
    // Load JSON file
    const loadJson = async () => {
      try {
        const response = await fetch(`/audios/${script}.json`);
        const data = await response.json();
        lipsyncRef.current = data;
        jsonRef.current = true;
      } catch (error) {
        console.error("Error loading JSON:", error);
        jsonRef.current = false;
      }
    };
    
    loadJson();
    
    // Reset mouth on script change
    resetMouth();
    
    prevScriptRef.current = script;
  }, [script]);

  const group = useRef();
  const [animation, setAnimation] = useState('Idle');

  const { scene } = useGLTF('/models/67e90607d9b62ad194b6ee87.glb');
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  
  const { animations: idleAnimation } = useFBX('animations/Idle.fbx');
  const { animations: wavingAnimation } = useFBX('animations/Waving.fbx');
  
  idleAnimation[0].name = 'Idle';
  wavingAnimation[0].name = 'Waving';
  
  const animationsRef = useRef([idleAnimation[0], wavingAnimation[0]]);
  
  const { actions } = useAnimations(animationsRef.current, group);
  
  useEffect(() => {
    if (!actions) return
    
    Object.values(actions).forEach(action => {
      if (action.isRunning()) {
        action.fadeOut(0.5)
      }
    })
    
    if (actions[animation]) {
      actions[animation].reset().fadeIn(0.5).play()
    }
    
    return () => {
      if (actions[animation]) {
        actions[animation].fadeOut(0.5)
      }
    }
  }, [animation, actions]);

  // Function to reset all mouth morphTargets to 0
  const resetMouth = () => {
    if (!nodes) return;
    
    Object.values(corresponding).forEach((value) => {
      if (nodes.Wolf3D_Head && 
          nodes.Wolf3D_Head.morphTargetDictionary && 
          nodes.Wolf3D_Head.morphTargetInfluences) {
        const index = nodes.Wolf3D_Head.morphTargetDictionary[value];
        if (index !== undefined) {
          nodes.Wolf3D_Head.morphTargetInfluences[index] = 0;
        }
      }
      
      if (nodes.Wolf3D_Teeth && 
          nodes.Wolf3D_Teeth.morphTargetDictionary && 
          nodes.Wolf3D_Teeth.morphTargetInfluences) {
        const index = nodes.Wolf3D_Teeth.morphTargetDictionary[value];
        if (index !== undefined) {
          nodes.Wolf3D_Teeth.morphTargetInfluences[index] = 0;
        }
      }
    });
  };

  useEffect(() => {
    if (playAudio && audioRef.current) {
      audioRef.current.play();
      if (script === "greeting") {
        setAnimation('Waving');
      } else {
        setAnimation('Idle');
      }
      
      // Reset mouth when audio ends
      audioRef.current.onended = () => {
        resetMouth();
        setAnimation('Idle');
      };
    } else if (!playAudio && audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      resetMouth();
    }
  }, [playAudio, script]);

  useFrame(() => {
    if (!audioRef.current || !nodes || !lipsyncRef.current) return;
    
    const currentAudioTime = audioRef.current.currentTime;
    
    // If audio is paused or ended, reset the mouth
    if (audioRef.current.paused || audioRef.current.ended) {
      resetMouth();
      return;
    }

    // Reset all mouth shapes first
    resetMouth();

    // Apply the appropriate mouth shape based on current time
    if (lipsyncRef.current.mouthCues) {
      for (let i = 0; i < lipsyncRef.current.mouthCues.length; i++) {
        const mouthCue = lipsyncRef.current.mouthCues[i];
        if (currentAudioTime >= mouthCue.start && currentAudioTime <= mouthCue.end) {
          const viseme = corresponding[mouthCue.value];
          
          if (viseme && nodes.Wolf3D_Head?.morphTargetDictionary?.[viseme] !== undefined) {
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[viseme]
            ] = 1;
          }
          
          if (viseme && nodes.Wolf3D_Teeth?.morphTargetDictionary?.[viseme] !== undefined) {
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[viseme]
            ] = 1;
          }
          
          break;
        }
      }
    }
  });

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Glasses.geometry} material={materials.Wolf3D_Glasses} skeleton={nodes.Wolf3D_Glasses.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
      <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
      <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
    </group>
  )
}

useGLTF.preload('/models/67e90607d9b62ad194b6ee87.glb')